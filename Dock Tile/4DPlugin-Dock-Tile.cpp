/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Dock-Tile.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Dock Tile
 #	author : miyako
 #	2020/02/06
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Dock-Tile.h"
#include "4DPlugin-JSON.h"
#include "NSBezierPath+DockTile.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kDeinitPlugin :/* main thread */
            case kServerDeinitPlugin:
                [[NSApp dockTile] setBadgeLabel:nil];
                break;
                
			// --- Dock Tile
            
			case 1 :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)DOCK_Get_badge, params);
//				DOCK_Get_badge(params);
				break;
			case 2 :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)DOCK_SET_BADGE, params);
//				DOCK_SET_BADGE(params);
				break;
			case 3 :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)DOCK_CANCEL_BOUNCE, params);
//				DOCK_CANCEL_BOUNCE(params);
				break;
			case 4 :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)DOCK_Bounce, params);
//				DOCK_Bounce(params);
				break;
			case 5 :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)DOCK_SET_ICON, params);
//				DOCK_SET_ICON(params);
				break;
			case 6 :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)DOCK_Get_icon, params);
//				DOCK_Get_icon(params);
				break;
			case 7 :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)DOCK_GET_SIZE, params);
//				DOCK_GET_SIZE(params);
				break;
			case 8 :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)DOCK_GET_SCREEN_FRAME, params);
//				DOCK_GET_SCREEN_FRAME(params);
				break;
            case 9 :
                DOCK_SET_PROGRESS(params);
                break;
            case 10 :
                DOCK_MENU(params);
                break;
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void DOCK_Get_badge(PA_PluginParameters params) {

    NSDockTile *dockTile = [[NSApplication sharedApplication]dockTile];

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    C_TEXT returnValue;
    
    returnValue.setUTF16String([dockTile badgeLabel]);
    returnValue.setReturn(pResult);
}

void DOCK_SET_BADGE(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    C_TEXT Param1;

    Param1.fromParamAtIndex(pParams, 1);
    
    NSDockTile *dockTile = [NSApp dockTile];
    
    if(Param1.getUTF16Length())
    {
        NSString *badgeLabel = Param1.copyUTF16String();
        [dockTile setBadgeLabel:badgeLabel];
        [dockTile display];
        [badgeLabel release];
    }else{
        [dockTile setBadgeLabel:nil];
    }
}

void DOCK_CANCEL_BOUNCE(PA_PluginParameters params) {

    NSInteger request = (NSRequestUserAttentionType)PA_GetLongParameter(params, 1);
    
    [[NSApplication sharedApplication]cancelUserAttentionRequest:request];
}

void DOCK_Bounce(PA_PluginParameters params) {

    NSRequestUserAttentionType type = (NSRequestUserAttentionType)PA_GetLongParameter(params, 1);

    NSInteger returnValue = [[NSApplication sharedApplication]requestUserAttention:type];
    PA_SetLongParameter(params, 1, (PA_long32)returnValue);
}

void DOCK_SET_ICON(PA_PluginParameters params) {

    PA_Picture p = PA_GetPictureParameter(params, 1);
    CGImageRef cgImage = (CGImageRef)PA_CreateNativePictureForScreen(p);
    
    if(cgImage) {
        NSImage *nsImage = [[NSImage alloc]initWithCGImage:cgImage size:NSZeroSize];
        CFRelease(cgImage);
        if(nsImage) {
            [[NSApplication sharedApplication]setApplicationIconImage:nsImage];
            [nsImage release];
        }
    }
}

void DOCK_Get_icon(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    
    NSImage * icon = [[NSApplication sharedApplication]applicationIconImage];
    if(icon) {

        NSRect imageRect = NSMakeRect(0, 0,
                                      icon.size.width,
                                      icon.size.height);
        CGImageRef image = [icon CGImageForProposedRect:(NSRect *)&imageRect context:NULL hints:NULL];
        CFMutableDataRef data = CFDataCreateMutable(kCFAllocatorDefault, 0);
        CGImageDestinationRef destination = CGImageDestinationCreateWithData(data, kUTTypeTIFF, 1, NULL);
        CFMutableDictionaryRef properties = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, NULL, NULL);
        CGImageDestinationAddImage(destination, image, properties);
        CGImageDestinationFinalize(destination);
        PA_Picture picture = PA_CreatePicture((void *)CFDataGetBytePtr(data), (PA_long32)CFDataGetLength(data));
        *(PA_Picture*) pResult = picture;
        CFRelease(destination);
        CFRelease(properties);
        CFRelease(data);
        
    }

}

void DOCK_GET_SIZE(PA_PluginParameters params) {

    NSDockTile *dockTile = [[NSApplication sharedApplication]dockTile];
    NSSize size = [dockTile size];
    
    PA_SetDoubleParameter(params, 1, size.width);
    PA_SetDoubleParameter(params, 2, size.height);
}

void DOCK_GET_SCREEN_FRAME(PA_PluginParameters params) {
    
    NSScreen *mainScreen = [NSScreen mainScreen];
    NSRect rect = [mainScreen visibleFrame];
    
    PA_SetDoubleParameter(params, 1, rect.origin.x);
    PA_SetDoubleParameter(params, 2, rect.origin.y);
    PA_SetDoubleParameter(params, 3, rect.size.width);
    PA_SetDoubleParameter(params, 4, rect.size.height);
}

void DOCK_SET_PROGRESS(PA_PluginParameters params) {
    CGFloat progress = (CGFloat) PA_GetDoubleParameter(params, 1);
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);

    // read options out of main thread
    DrawOptions drawOptions;
    if (options) {
        drawOptions.type =  (DockIconProgressType) ob_get_n(options, L"style");
        if (ob_is_defined(options, L"lineWidth")) {
            drawOptions.lineWidth = ob_get_n(options, L"lineWidth");
        }
        if (ob_is_defined(options, L"radius")) {
            drawOptions.radius = ob_get_n(options, L"radius");
        }
        if (ob_is_defined(options, L"inset")) {
            drawOptions.inset = ob_get_n(options, L"inset");
        }
        if (ob_is_defined(options, L"color")) {
            PA_ObjectRef optionColor = ob_get_o(options, L"color");
            if(optionColor) {
                CGFloat r, g, b, a;
                r = ob_get_n(optionColor, L"red");
                g = ob_get_n(optionColor, L"green");
                b = ob_get_n(optionColor, L"blue");
                if (ob_is_defined(optionColor, L"alpha")) {
                    a = ob_get_n(optionColor, L"alpha");
                } else {
                    a = 1;
                }
                drawOptions.color = [NSColor colorWithRed:r green:g blue:b alpha:a];
            }
        }
    }
    // change app icon by drawing on it
    dispatch_async(dispatch_get_main_queue(), ^{
        if (![NSApp.dockTile.contentView isKindOfClass: [NSImageView class]]) {
            NSApp.dockTile.contentView = [[NSImageView alloc] init];
        }
        if (progress <= 0 || progress>=1) {
            ((NSImageView *)NSApp.dockTile.contentView).image = NSApp.applicationIconImage;
        } else {
            ((NSImageView *)NSApp.dockTile.contentView).image = draw(NSApp.applicationIconImage, progress, drawOptions);
        }
        [NSApp.dockTile display];
    });
    
}

#import <objc/objc-class.h>
@interface DockDelegate : NSObject
+ (id)shared;
- (void) menuItemAction:(NSMenuItem *)sender;
- (NSMenu *)applicationDockMenu:(NSApplication *)sender;
@end
@implementation DockDelegate
+ (id)shared {
    static DockDelegate *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (void) menuItemAction:(NSMenuItem *)sender
{
    NSLog(@"Menu Item Action");
    // TODO execute sender method with name [sender representedObject]
    // in a thread that 4D could execute it
    dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void){
        PA_Unichar length[] = { 'T', 'E', 'S', 'T','(',')', 0 };
        PA_Unistring key = PA_CreateUnistring(&length[0]);
        PA_ExecuteMethod(&key);
    });
}

- (NSMenu *)applicationDockMenu:(NSApplication *)sender
{
    NSMenu *menu = [[[NSMenu alloc] initWithTitle:@"dock app menu"] autorelease];
    [menu setAutoenablesItems: NO];
    
    // TODO create menu according to DOCK MENU object parameters
    NSMenuItem *item = [[[NSMenuItem alloc] initWithTitle:@"My method" action: @selector(menuItemAction:) keyEquivalent:@""] autorelease];
    [item setEnabled: YES];
    [item setTarget: [DockDelegate shared]];
    [item setRepresentedObject: @"quit"]; // TODO add here data from params, ie. 4d method name
    [menu addItem: item];

    return menu;
}

@end

void DOCK_MENU(PA_PluginParameters params) {
    // TODO read params as object to build menu item, set data in [DockDelegate shared]
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    if (ob_is_defined(options, L"items")) {
        // convert to struct the array of object
    }

    dispatch_async(dispatch_get_main_queue(), ^{
        Method delegateMethod = class_getInstanceMethod(objc_getClass("DockDelegate"), @selector(applicationDockMenu:));
        IMP imp = method_getImplementation(delegateMethod);
        class_addMethod([[[NSApplication sharedApplication] delegate] class], @selector(applicationDockMenu:), imp, method_getTypeEncoding(delegateMethod));
    });
}

// MARK:- draw

void drawProgressBar(NSRect dstRect, CGFloat progress, DrawOptions options) {
    if (options.lineWidth<=0) {
        options.lineWidth = 10;
    }

    NSRect bar = CGRectMake(0, 20, dstRect.size.width, options.lineWidth);
    [[options.color colorWithAlphaComponent: 0.8f] set];
    [[NSBezierPath bezierPathWithRoundedRect: bar xRadius: bar.size.height / 2 yRadius: bar.size.height] fill];

    NSRect barInnerBg = CGRectInset(bar, 0.5, 0.5);
    [[[NSColor blackColor] colorWithAlphaComponent: 0.8f] set];
    [[NSBezierPath bezierPathWithRoundedRect: barInnerBg xRadius: barInnerBg.size.height / 2 yRadius: barInnerBg.size.height / 2] fill];

    NSRect barProgress = CGRectInset(bar, 1, 1);
    barProgress.size.width = barProgress.size.width * CGFloat(progress);
    [options.color set];
    [[NSBezierPath bezierPathWithRoundedRect: barProgress xRadius: barProgress.size.height / 2 yRadius: barProgress.size.height / 2] fill];
}

void drawProgressCircle(NSRect dstRect, CGFloat progress, DrawOptions options) {
    if (options.radius<=0) {
        options.radius = 30.0f;
    }
    if (options.lineWidth<=0) {
        options.lineWidth = 4;
    }

    ProgressCircleShapeLayer* progressCircle = [[ProgressCircleShapeLayer alloc] initWithRadius:options.radius center: CGPointMake(CGRectGetMidX(dstRect), CGRectGetMidY(dstRect))];
    progressCircle.strokeColor = options.color.CGColor;
    progressCircle.lineWidth = options.lineWidth;
    [progressCircle setProgress: progress];
    [progressCircle renderInContext: [NSGraphicsContext.currentContext CGContext]];
}

void drawProgressSquircle(NSRect dstRect, CGFloat progress, DrawOptions options) {
    CGFloat defaultInset = 14.4;
    NSRect rect = CGRectInset(dstRect, defaultInset, defaultInset);
    if (options.inset>0) {
        rect = CGRectInset(rect, options.inset, options.inset);
    }
    if (options.lineWidth<=0) {
        options.lineWidth = 5;
    }

    ProgressSquircleShapeLayer* progressSquircle = [[ProgressSquircleShapeLayer alloc] initWithRect: rect];
    progressSquircle.strokeColor = options.color.CGColor;
    progressSquircle.lineWidth = options.lineWidth;
    [progressSquircle setProgress: progress];
    [progressSquircle renderInContext: [NSGraphicsContext.currentContext CGContext]];
}

NSImage* draw(NSImage* appIcon, CGFloat progress, DrawOptions options) {
    return [NSImage imageWithSize:appIcon.size flipped:NO drawingHandler:^BOOL(NSRect dstRect) {
        NSGraphicsContext.currentContext.imageInterpolation = NSImageInterpolationHigh;
        [appIcon drawInRect:dstRect];
        switch(options.type) {
            case DockIconProgressBar:
                drawProgressBar(dstRect, progress, options);
                break;
            case DockIconProgressCircle:
                drawProgressCircle(dstRect, progress, options);
                break;
            case DockIconProgressSquircle:
                drawProgressSquircle(dstRect, progress, options);
                break;
        }
        return YES;
    }];
}
